#!/bin/bash
function configure() {
	VOLID="LINUX_RECOVERY_IMAGE"
	ROOT="root"
	ISO="out.iso"
	INSTALL_LANG=en_AU.UTF-8
	INSTALL_LANG_ENC=UTF-8
	INSTALL_KEYMAP=us
	INSTALL_TZ=Australia/Melbourne
	INSTALL_FONT=ter-v22n
	INSTALL_USER=user
	INSTALL_USER_PASSWORD=user
	INSTALL_ROOT_PASSWORD=root
}

true && return 1 2>/dev/null # exit if sourced
cd -- "$PWD" || exit "$?"
IFS=$'\n'
set -o errexit -o nounset -o pipefail || exit 1
function print_color() {
	local color
	color="$1"
	shift
	printf "\x1b[38;5;${color}m::\x1b[0m %s\n" "$@"
}
function print() {
	print_color 14 "$@"
	return 0
}
function debug() {
	print_color 13 "$@"
	return 0
}
function warn() {
	print_color 11 "$@" >&2
	return 0
}
function error() {
	print_color 9 "$@" >&2
	return 1
}
function print_raw() {
	printf "%s\n" "$@"
}
function check_installed() {
	for i in "$@"; do
		if ! command -v "$i" &>/dev/null; then
			error "$i could not be found"
		fi
	done
}
function check_root() {
	if [[ $EUID -ne 0 ]]; then
		error "This script must be run as root"
	fi
}
function confirm() {
	local REPLY
	local -a args
	local last
	args=("$@")
	last="$(("${#args[@]}" - 1))"
	args["$last"]="${args["$last"]} [Y/n]"

	print "${args[@]}"
	read -n 1 -r
	printf "\n"
	if [[ "$REPLY" =~ ^[Yy]?$ ]]; then return 0; fi
	error "Aborted"
}
function create_symlink() {
	local target
	local file
	target="$1"
	file="$2"

	if [[ -L "$file" ]]; then
		unlink -- "$file"
	fi
	if [[ -e "$file" ]]; then
		error "$file: file already exists as another type"
	fi
	ln -s -- "$target" "$file"
	debug "Symlink created: $file -> $target"
}
function create_dir() {
	local dir
	dir="$1"
	if [[ -d "$dir" ]]; then
		debug "Directory already exists: $dir"
		return 0
	fi
	if [[ -e "$dir" ]]; then
		error "$dir: file already exists as another type"
	fi
	mkdir -- "$dir"
	debug "Directory created: $dir"
}
function copy_file() {
	local src
	local dest
	src="$1"
	dest="$2"
	if [[ -e "$dest" ]]; then
		unlink -- "$dest"
	fi
	cp -- "$src" "$dest"
	debug "File copied: $src -> $dest"
}
function move_file() {
	local src
	local dest
	src="$1"
	dest="$2"
	if [[ -e "$dest" ]]; then
		unlink -- "$dest"
	fi
	mv -- "$src" "$dest"
	debug "File moved: $src -> $dest"
}
function delete_file() {
	local file
	file="$1"
	if [[ -e "$file" ]]; then
		unlink -- "$file"
		debug "File deleted: $file"
	fi
}
function ensure_exists() {
	local file
	file="$1"
	if [[ ! -e "$file" ]]; then
		error "$file: file doesn't exist"
	fi
}
function ensure_does_not_exist() {
	local file
	file="$1"
	if [[ -e "$file" ]]; then
		error "$file: file already exists"
	fi
}
function install_packages() {
	local root
	local -A packages
	local -A force_packages
	root="$1"
	shift
	if [[ -z "$root" || ! -d "$root" ]]; then
		error "Invalid root directory"
	fi
	packages=()
	force_packages=()
	for i in "$@"; do
		if [[ -z "$i" ]]; then
			continue
		fi
		if [[ "${i:0:1}" == "!" ]]; then
			force_packages["${i:1}"]=1
			packages["${i:1}"]=1
			continue
		else
			force_packages["$i"]=0
			packages["$i"]=1
		fi
	done
	IFS=$'\n'
	if [[ -d "$root"/var/lib/pacman ]]; then
		while IFS= read -r line; do
			if [[ "${force_packages[$line]}" == "0" ]]; then
				unset -v "packages[$line]"
			fi
		done < <(pacman --root "$root" -Qq - <<<"${!packages[*]}" 2>/dev/null)
	fi
	if [[ ${#packages[@]} -eq 0 ]]; then
		debug "Packages are already installed"
		return 0
	fi
	debug "Installing ${#packages[@]} packages..."
	basestrap -c -- "$root" - <<<"${!packages[*]}"
}
check_installed mksquashfs chroot grub-install mkdir ln cp mv unlink basestrap pacman printf grub-mkrescue awk mkfs.ext4 tar
check_root

configure
BOOT="$ROOT/boot"
ROOTFS="rootfs.img"
function clean() {
	delete_file "$ISO"
	delete_file "$ROOTFS"
}
function make() {
	ensure_exists grub.cfg
	ensure_exists update-dracut

	confirm "Script settings: " \
		"  Root directory is at '$ROOT'." \
		"  Root filesystem image is at '$ROOTFS'." \
		"  Output ISO file will be saved to '$ISO'." \
		"  ISO label is '$VOLID'." \
		"Recovery environment options:" \
		"  Language is '$INSTALL_LANG'." \
		"  Language encoding is '$INSTALL_LANG_ENC'." \
		"  Keymap is '$INSTALL_KEYMAP'." \
		"  Timezone is '$INSTALL_TZ'." \
		"  User is '$INSTALL_USER'." \
		"  Font is '$INSTALL_FONT'." \
		"Change these settings in the script if needed." \
		"Continue?"

	PACKAGES=(base base-devel dinit-base dinit dinit-rc dbus-dinit seatd-dinit nano neovim git curl wget sudo linux linux-firmware intel-ucode amd-ucode mandoc man-pages efibootmgr grub dracut os-prober networkmanager-dinit less terminus-font baobab gdm-dinit gnome-session gnome-backgrounds gnome-calculator gnome-characters gnome-clocks gnome-color-manager gnome-console gnome-control-center gnome-font-viewer gnome-keyring gnome-menus gnome-settings-daemon gnome-shell gnome-shell-extensions gnome-software gnome-system-monitor gnome-text-editor gnome-user-docs gnome-user-share gvfs loupe nautilus simple-scan snapshot sushi xdg-desktop-portal-gnome xdg-user-dirs-gtk firefox okular squashfs-tools device-mapper gparted dosfstools jfsutils f2fs-tools btrfs-progs exfatprogs ntfs-3g reiserfsprogs udftools xfsprogs nilfs-utils polkit gpart mtools xorg-xhost qemu-guest-agent-dinit usbutils spice-vdagent-dinit)
	# TODO: gparted optional dependencies
	create_dir "$ROOT"
	print "Installing packages"
	install_packages "$ROOT" "${PACKAGES[@]}"
	print "Configuring system"
	print_raw "$INSTALL_LANG $INSTALL_LANG_ENC" >"$ROOT/etc/locale.gen"
	print_raw "LANG=$INSTALL_LANG" >"$ROOT/etc/locale.conf"
	print_raw "KEYMAP=$INSTALL_KEYMAP" "FONT=$INSTALL_FONT" >"$ROOT/etc/vconsole.conf"
	print_raw "%wheel ALL=(ALL) ALL" >"$ROOT"/etc/sudoers.d/wheel
	print_raw '[daemon]' 'AutomaticLoginEnable=True' "AutomaticLogin=$INSTALL_USER" 'WaylandEnable=true' >"$ROOT"/etc/gdm/custom.conf
	create_symlink /usr/share/zoneinfo/"$INSTALL_TZ" "$ROOT/etc/localtime"
	# shellcheck disable=SC2016
	artix-chroot "$ROOT" bash -c '(id -u -- "$1" || useradd --create-home -- "$1") && locale-gen &&
usermod --append --groups wheel --shell /bin/bash -- "$1"' bash "$INSTALL_USER"
	chroot "$ROOT" passwd root <<<"$INSTALL_ROOT_PASSWORD"$'\n'"$INSTALL_ROOT_PASSWORD"
	chroot "$ROOT" passwd "$INSTALL_USER" <<<"$INSTALL_USER_PASSWORD"$'\n'"$INSTALL_USER_PASSWORD"
	create_symlink ../NetworkManager "$ROOT"/etc/dinit.d/boot.d/NetworkManager
	create_symlink ../seatd "$ROOT"/etc/dinit.d/boot.d/seatd
	create_symlink ../dbus "$ROOT"/etc/dinit.d/boot.d/dbus
	create_symlink ../gdm "$ROOT"/etc/dinit.d/boot.d/gdm
	create_symlink ../qemu-ga "$ROOT"/etc/dinit.d/boot.d/qemu-ga
	create_symlink ../spice-vdagentd "$ROOT"/etc/dinit.d/boot.d/spice-vdagentd
	create_symlink nvim "$ROOT"/usr/bin/vi
	create_symlink nvim "$ROOT"/usr/bin/vim

	print "Creating initramfs image with dracut"
	print_raw 'add_dracutmodules+=" dmsquash-live dm udev-rules kernel-modules kernel-modules-extra "' 'install_items+=" /usr/bin/lsblk /usr/bin/lsmod /usr/bin/lspci /usr/bin/lsusb "' >"$ROOT"/etc/dracut.conf.d/02-squashfs.conf
	artix-chroot "$ROOT" bash - <update-dracut

	print "Creating ext4 filesystem image, this may take a while"
	delete_file "$ROOTFS"
	# creates a ext4 image of the root directory, excluding the boot directory
	tar --directory "$ROOT" --exclude /boot --one-file-system --create \
		--xattrs --acls --numeric-owner --preserve-permissions --xattrs --xattrs-include=* --acls --atime-preserve . |
		mkfs.ext4 -d - -- "$ROOTFS" 10G
	resize2fs -M -- "$ROOTFS" # shrink the filesystem to the minimum size

	print "Creating squashfs filesystem image, this may take a while"
	SQUASHFS_DIR="$BOOT/LiveOS"
	SQUASHFS_PATH="$SQUASHFS_DIR/squashfs.img"
	create_dir "$SQUASHFS_DIR"
	mksquashfs - "$SQUASHFS_PATH" -p '/ d 0755 0 0' -p '/LiveOS/ d 0755 0 0' -p '/LiveOS/rootfs.img f 0644 0 0 cat' -noappend -no-recovery <"$ROOTFS"

	print "Generating GRUB configuration"
	create_dir "$BOOT"/boot
	create_dir "$BOOT"/boot/grub
	awk -v VOLID="$VOLID" '{gsub(/\$VOLID/, VOLID);}1' grub.cfg >"$BOOT"/boot/grub/grub.cfg

	print "Creating ISO"
	grub-mkrescue -o "$ISO" "$BOOT" -- -volid "$VOLID"

	print "Output ISO: $ISO"
}
function main() {
	if [[ "$#" == "0" ]]; then
		print "Available commands:"
		print "clean: Remove generated files"
		print "make: Create the recovery ISO"
		return 0
	fi
	if [[ "$#" != "1" ]]; then
		error "Invalid usage" >&2
		return 1
	fi
	case "$1" in
	clean)
		clean
		return "$?"
		;;
	make)
		make
		return "$?"
		;;
	*)
		error "Invalid command" >&2
		return 1
		;;
	esac
}
main "$@"
